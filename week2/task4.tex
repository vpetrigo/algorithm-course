Задача: сдача минимальным количеством монет
Вход: размер сдачи n в копейках
Выход: минимальное количество монет номиналом 25, 10, 5 и 1 копеек

Пример:
Необходимо выдать сдачу 57 копеек.
Надежный шаг:
Существует оптимальное решение, содержащее монету максимального номинала.
Шаг | Монета | Остаток
$
1. \quad \;\; 25 : \qquad 57 - 25 = 32 \\
2. \quad \;\; 25 : \qquad 32 - 25 = 7 \\
3. \quad \;\;\; 5 : \qquad\: 7 - 5 = 2 \\
4. \quad \;\;\; 1 : \qquad\: 2 - 1 = 1 \\
5. \quad \;\;\; 1 : \qquad\: 1 - 1 = 0 \\
$


$\text{Алгоритм MonetCount(n):} \\
coin\_nom \leftarrow \left\{25, 10, 5, 1\right\} \\
\text{остаток} \leftarrow n \\
\text{для всех монет в coin_num:} \\
    \quad\text{число_монет}_n = \left \lfloor{\frac{\text{остаток}}{coin\_nom_n}}\right \rfloor  \\
    \quad\text{добавить в решение число монет} \\
    \quad\text{остаток} = \text{остаток} \mod coin\_nom_n \\
\text{вернуть решение}
$

Время работы: будем считать, что входное число $n$ не превышает $2^64$ и число номиналов также не превышает данного значения.
Так как все числа умещаются во внутреннюю память компьютера, то арифметические операции деления и взятия остатка будут
выполняться за $O(n)$. Следовательно, так как размер доступных номиналов монет у нас постоянный, нахождение числа монет
разных номинало для сдачи тоже, то алгоритм работает за время $O(n)$. \quad\blacksquare

Пример номиналов монет, для которых жадный алгоритм построит неоптимальное решение:
Допустим, имеем следующие номиналы $\{25, 10, 4\}$ копеек. Построенный на предыдущем шаге жадный алгоритм найдет
неоптимальное решение, например, при нахождении сдачи на 41 копейку. Будет взята 1 монета номиналом 25, 1 монету номиналом
10, после этого будет невозможно добрать оставшиеся 6 копеек с помощью 4 копеечных номиналов. Оптимальный алгоритм
должен был бы использовать 1 монету в 25 копеек и 4 по 4.