Задача:
Мы хотим разбить данные $n$ натуральных чисел $a_1, \ldots ,a_n$ на три части с равной суммой. Например, числа $\left(1,2,3,4,4,5,8\right)$ так разбить можно: $(1,8)$, $(4,5)$, $(2,3,4)$, а числа $\left(2,2,3,5\right)$ — нет. Приведите алгоритм со временем работы $O(nS^2)$, где $S=\sum_{i=1}^n a_i$

Алгоритм:
Для начала определим для каких последовательностей мы должны искать разбиение:
1. Если $\sum_{i=1}^n a_i \mod 3 \neq 0$, то такую последовательность нельзя разбить на $3$ части с равной суммой. Простой пример - входные числа $(2, 2, 4)$.
2. Если $\sum_{i=1}^n a_i \mod 3 = 0$, то здесь необходимо доказать наличие/отсутствие разбиения на $3$ части с равной суммой.

Сформулируем подзадачи, которые необходимо решить:
- Общая сумма множества ${a_1, \ldots a_n}$ $S=\sum_{i=1}^n a_i$. Обозначим за $\displaystyle{A = \frac{S}{3}}$.
- Очевидно, что если $\displaystyle{S_1 = \sum_{i}^k a_i = \frac{S}{3}}$ и $\displaystyle{S_2 = \sum_{j}^k a_j = \frac{S}{3}}$, то оставшиеся слагаемые также сформируют разбиение с суммой $\displaystyle{S_3 = \frac{S}{3}}$. Так как если $\displaystyle{S = S_1 + S_2 + S_3 = \frac{S}{3} + \frac{S}{3} + S_3}$, то все очевидно.
- В контексте трех множеств элемент $a_i$ должен попасть либо в первое, либо во второе, либо в третье разбиение.
- Для решения этой задачи нам потребуется массив $D[0 \ldots n][0 \ldots A][0 \ldots A]$, где $n$ - общее число элементов в множестве. Решение о том, можно ли разбить на входной массив чисел на три множества будет лежать в ячейке $D[n][A][A]$. $1$ - индекс массива $D$ отвечает за текущее количество элементов в множестве, $2$ и $3$ за текущую сумму подмножества.
- Начальные данные $D[i][0][0] = 1,\: i \in [0 \ldots n]$, так как для любого набора входных данных мы можем просто не взять ни один элемент и получится $3$ пустых множества.
$D[0][S_1][S_2] = 0$, так как если у нас нет ни одного элемента, то и получить суммы $S_1 + S_2 > 0$ мы не сможем.
- Рекуррентное соотношение для $D[i][S_1][S_2] = \max\left(D[i - 1][S_1][S_2], \: D[i - 1][S_1 - a_i][S_2], \: D[i - 1][S_1][S_2 - a_i]\right)$, то есть, либо $S_1$ или $S_2$ уже содержит элемент $a_i$, либо можно взять разбиение $a_1, \ldots a_i$ и добавить к нему $a_i$.

Динамическое программирование сверху вниз:
-----------------------------------------------
Массив $D[0 \ldots n][0 \ldots A][0 \ldots A] \leftarrow [\infty, \ldots \infty]$
Функция $\texttt{3PartitionTD}(i, S_1, S2)$:
если $D[i][S_1][S_2] = \infty$:
    если $S_1$ = 0 и $S_2 = 0$:
        $D[i][S_1][S_2] = 1$
    иначе если $i = 0$:
        если $S_1 = 0$ и $S_2 = 0$:
            $D[i][S_1][S_2] = 1$
        иначе:
            $D[i][S_1][S_2] = 0$
    иначе:
        $D[i][S_1][S_2] = 3PartitionTD(i - 1, S_1, S_2)$
        если $A[i] \leq S_1$:
            $D[i][S_1][S_2] = \max\left(D[i][S_1][S_2], 3PartitionTD(i - 1, S_1 - A[i], S_2)\right)$
        если $A[i] \leq S_2$:
            $D[i][S_1][S_2] = \max\left(D[i][S_1][S_2], 3PartitionTD(i - 1, S_1, S_2 - A[i])\right)$
вернуть $D[i][S_1][S_2]$
-----------------------------------------------

Динамическое программирование снизу вверх:
-----------------------------------------------
Функция $\texttt{3PartitionBU}(M[1 \ldots n])$:
$S = \sum_{i=1}^n M[i]$
если $S % 3 = 0$:
    $A = S / 3$
иначе:
    вернуть $0$

создать массив $D[0 \ldots n][0 \ldots A][0 \ldots A]$

для $i$ от $1$ до $n$:
  $D[i][0][0] = 1$
для $S_1$ от $0$ до $A$:
  для $S_2$ от $0$ до $A$:
    если $S_1 = 0$ и $S_2 = 0$:
        $D[0][S1][S2] = 1$
    иначе:
        $D[0][S1][S2] = 1$

для $i$ от $1$ до $n$:
  для $S_1$ от $0$ до $A$:
    для $S_2$ от $0$ до $A$:
      $D[i][S_1][S_2]=D[i-1][S_1][S_2]$
      если $M[i] \leq S_1$:
        $D[i][S_1][S_2] = \max(D[i][S_1][S_2], D[i - 1][S_1 - M[i]][S_2])$
      если $M[i] \leq S_2$:
        $D[i][S_1][S_2] = \max(D[i][S_1][S_2], D[i - 1][S_1][S_2 - M[i]])$

вернуть $D[n][A][A]$
-----------------------------------------------

Время работы: время работы составляет $O(nS^2)$, так как нам необходимо обойти каждое число входного массива и проверить, входит ли оно в одно из разбиений.

Для восстановления разбиения можно