Задача:
Приведите алгоритм, который по данному натуральному числу n и набору натуральных чисел C={c1=1,c2,…,ck} находит
минимальное число p, такое что n можно представить как сумму p чисел из набора C, за время O(kn) (числа в представлении
могут повторяться; хотя бы одно представление всегда есть, поскольку c1=1).

Алгоритм:
Опишем задачу:
Вход: набор доступных монет $C[c_1, \ldots c_n]$, число $n$ - сумма для размена
Выход: минимальное число $p$, такое что $n$ можно представить как сумму $p$ чисел из набора $C$

Определим подзадачи, которые необходимо решить:
- если при оптимальном наборе монет $p$ (при котором достигается минимальное количество используемых монет) убрать монету
 с номиналом $c_i$, то мы получим оптимальный набор для суммы $n - c_i$
- так как в наборе всегда имеется монета номинала $1$, то для любого входного числа $n$ будет хотя бы одно представление,
содержащее $n$ монет номинала $1$
- $D[n]$ - минимальное число монет, которые необходимы для представления числа $n$
- тогда $\displaystyle{D[n] = \min_{c_i \leq n}\left\{D[n], 1 + D[n - c_i]\right\}}$, так как мы можем взять либо дополнительно монету
меньшего номинала, либо взять более крупную.

Функция $\texttt{CountCoinsTD}[C[1 \ldots k], \: n]$:
если $n$ нет в хеш-таблице $Counted$:
    $count = n$
    для всех $i$ от $1$ до $k$:
        если $c_i \leq n$:
            $count \leftarrow \min\left\{count, CountCoinsTD(C, n - c_i)\right\}$
    $Counted[n] = count$
вернуть $Counted[n]$

Время работы:
- Время работы получившегося алгоритма $O(kn)$, так как размер массива доступных номиналов монет имеет размер $k$, а также
необходимо спуститься на $n$ уровней, так как алгоритм идет сверху вниз.
- За счет использования хеш-таблицы накладные расходы рекурсивных вызовов сведены к минимуму.

Также ниже представлен пример итеративного алгоритма:
Функция $\texttt{CountCoinsBU}[C[1 \ldots k], \: n]$:
создать массив $D[0 \ldots n]$
$D[0 \ldots n] \leftarrow [0, 1, 2 \ldots n]$

для $c$ от $1$ до $n$:
    для $i$ от $1$ до $k$:
        если $c_i \leq c$
            $D[c] = \min\left\{D[c], 1 + C[c - c_i]\right\}$

вернуть $D[n]$

Восстановление ответа:
создать массив $Result[1 \ldots D[n]]$
$value \leftarrow 1$
$coins\_amount \leftarrow D[n] - 1$
для $i$ от $n - 1$ до $0$:
    если $coins\_amount = D[i]$ и $value$ в $C[1 \ldots n]$:
        $Result.push\_back(value)$
        $value \leftarrow 1$
        $coins\_amount \leftarrow coins\_amount - 1$
    иначе:
        $value \leftarrow value + 1$

Время работы: $O(n)$ - так как мы проходим по массиву $D$ один раз и делаем это за $n$ шагов