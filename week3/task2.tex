Задача:
Дан упорядоченный по возрастанию массив различных целых чисел A[1…n]: A[1]<A[2]<…<A[n].
Постройте алгоритм, проверяющий за время O(logn), найдётся ли такое i, что A[i]=i.

Доказательство:
Имеется строго неубывающая последовательность $i \in [1 \ldots n]$, где $A[i] < A[i + 1]$.
Условием того, что $A[i] = i$ будет являться то, что для некоторого $i \colon
B[i] = A[i] - i = 0$, причем $B[i] \leq B[i + 1]$ (так как разница соседних элементов уменьшается на $1$, то равенство нестрогое).

Алгоритм поиска аналогичен двоичному поиску (необходимо найти 0 в последовательности $B[i]$):
---------------------------------------------
Функция $\texttt{FindZero($A[1 \ldots n]$)}$:
$l \leftarrow 0, r \leftarrow n$
если ($A[l] - l > 0$) или ($A[r] - r < 0$)
    вернуть $-1$
пока $l \leq r$:
    $m \leftarrow \left \lfloor {\frac{l + r}{2}} \right \rfloor$
    если $A[m] - m = 0$:
        вернуть $m$
    иначе если $A[m] - m > 0$:
        $r \leftarrow m - 1$
    иначе:
        $l \leftarrow m + 1$
вернуть $-1$
---------------------------------------------
Корректность работы: так как последовательность неубывающая и мы проверяем, что $B[l] \leq 0$ и $B[r] \geq 0$, то алгоритм
вернет либо индекс элемента для которого выполняется равенство $A[i] = i$, либо сообщит, что такого элемента нет, вернув $-1$.
Время работы: $O(\log{n})$, так как мы постоянно делим область зоны поиска пополам. $\quad\blacksquare$